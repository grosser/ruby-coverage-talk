<!DOCTYPE html>
<html>
<head>
  <title>Actionable Code Coverage</title>
  <meta charset="utf-8">
  <style>
    body {
      font-family: "Lucida Grande", sans-serif;
    }

    /* make slides and background not have gap between them */
    .remark-slide-scaler {
      -webkit-box-shadow: none;
    }

    /* make slides and background blend in */
    .remark-container {
      background: #272822;
    }

    .remark-code, .remark-inline-code {
      font-family: 'Monaco', monospace;
    }

    .remark-slide-content {
      background: #272822;
      color: white;
      text-shadow: 0 0 20px #333;
      font-size: 30px;
      line-height: 2;
    }

    .remark-slide-content pre {
      text-shadow: none;
    }

    .remark-slide-content h1 {
      font-size: 50px;
    }

    .remark-slide-number {
      display: none;
    }

    .table th, .table td {
      padding: 5px 10px;
      text-align: right;
    }
  </style>
</head>
<body>
<textarea id="source">
  class: center, middle

  # Actionable Code Coverage

  &nbsp;

  ???

  - Understanding how code coverage works and it's limitations
  - How to turn coverage it into a helpful tool instead of an afterthought/metric

  ---
  class: center, middle

  # Actionable Code Coverage

  github.com/grosser/ruby-coverage-talk

  ???

  - not just a talk, but repo with runnable examples + markdown slides
  - a maintainable deep dive for new developers (intro + workflows + limits)

  ---

  # Michael Grosser

  Senior Staff Engineer @ Zendesk<br/>
  (Hiring in SF/Madison/Dublin/CPH/Sydney)

  <table>
    <tr>
      <td><img width="230" src="assets/Avatar.png"></img></td>
      <td>&nbsp;&nbsp;</td>
      <td style="vertical-align: top">
        rubygems.org grosser<br/>
        github.com/grosser<br/>
        twitter.com/grosser<br/>
        grosser.it
      </td>
    </tr>
  </table>

  ???

  - job: help other devs, build infrastructure, make them more efficient
  - build lots of gems for testing + coverage and onboarded giant projects on them

  ---

  # Plan

  - Code Coverage Overview
  - Actionable Coverage
  - Hack Forked Coverage
  - Coverage Wishlist

  ???

  - overview: get everyone onto the same level
  - action: problems with current approaches, how to improve them, how to migrate projects piecemeal without breaking
  - fork: how parallel/forked processes can share coverage calculations
  - wishlist: basics for better tooling

  ---

  # Code Coverage Overview

  - builtin C library, no gems needed
  - Enable before loading code
  - Slows down execution

  ???

  - slow: do not always run in tests

  ---

  # Line Coverage

  <!-- see 01-Internals/coverage_line.rb -->
  ```Ruby
  require 'coverage' # -> coverage.so
  Coverage.start     # enable for newly loaded code
  require_relative 'example'
  example
  Coverage.result    # disable

  {"example.rb"=>[1, 1, 0, nil, 1, nil, nil]}
  ```

  ???

  - simplest form
  - result has side-effect of disabling, can use peek_result
  - 1 = hit once
  - 0 = never hit
  - nil = not code (end/else etc)

  ---

  # Line Coverage

  <!-- see 01-Internals/example.rb -->
  ```Ruby
  {"example.rb"=>[1, 1, 0, nil, 1, nil, nil]}

  def example             # 1 - Covered, loaded not ran
    if 1 == 2             # 1 - Covered, ran once
      "a"                 # 0 - Not-Covered
    else                  # nil
      3 == 2 ? "b" : "c"  # 1 - Covered, ran once
    end                   # nil
  end                     # nil
  ```

  ???

  - we hit example and the second branch
  - problem: in else the 3==2 has 2 outcomes, "b" never reached ... should rewrite as *next slide*

  ---

  # Line Coverage

  <!-- see 01-Internals/example_expanded.rb -->
  ```Ruby
  {"example.rb"=>[1, 1, 0, nil, 1, 0, nil, 1, nil, nil, nil]}
                                =================
  ...
      if 3 == 2           # 1 - Covered
        "b"               # 0 - Not Covered
      else                # nil
        "c"               # 1 - Covered
      end                 # nil
  ...
  ```

  ???

  - enforce via rubocop ?
  - use branch coverage! 2.5+

  ---

  # Branch Coverage

  <!-- see 01-Internals/coverage_branch.rb -->
  ```Ruby
  require 'coverage'
  Coverage.start branches: true # Ruby 2.5+
  require_relative 'example'
  example
  Coverage.result
  ```

  ???

  - easy right ? *next slide* NO!

  ---

  # Branch Coverage

  ```Ruby
  "example.rb"=>{:branches=>{
    # type, id, start line, start char, end line, end char
    [:if, 0, 5, 4, 5, 22]=>{
      [:then, 1, 5, 13, 5, 16]=>0,
      [:else, 2, 5, 19, 5, 22]=>1
    },
    [:if, 3, 2, 2, 6, 5]=>{
      [:then, 4, 3, 4, 3, 7]=>0,
      [:else, 5, 5, 4, 5, 22]=>1
    }
  ```

  ???

  - big hash where keys are the branches ... ignore + first 2 items are kind+index ... ignore
  - only care for last 4 items ... look back at code

  ---

  # Branch Coverage

  <!-- see 01-Internals/example.rb -->
  ```Ruby
  # char 4-22 = Y | char 13-16 = N | char 19-22 = Y

  def example
    if 1 == 2
      "a"
    else
      3 == 2 ? "b" : "c"
      YYYYYYYYYYYYYYYYYY
               NNN   YYY
    end
  end
  ```

  ???

  - enough info for simple tooling
  - slower than line
  - does not detect ||= / optional params
  - for prod to find dead code prefer oneshot

  ---

  # Oneshot Coverage

  <!-- see 01-Internals/coverage_oneshot.rb -->
  ```Ruby
  require 'coverage'
  Coverage.start oneshot_lines: true # Ruby 2.6+
  require_relative 'example'
  5.times { example }
  Coverage.result
  {"example.rb"=>{:oneshot_lines=>[1, 2, 5]}}
  ```

  ???

  - fast: removed after execution
  - no oneshot_branches

  ---

  # Oneshot Coverage

  <!-- see 01-Internals/example.rb -->
  ```Ruby
  # {"example.rb"=>{:oneshot_lines=>[1, 2, 5]}}
  def example             # Covered
    if 1 == 2             # Covered
      "a"                 # ?
    else                  # ?
      3 == 2 ? "b" : "c"  # Covered
    end                   # ?
  end                     # ?
  ```

  ???

  - bad for automation, does not show uncovered/uncoverable<br/>
  need ruby parser to know what is uncoverable

  ---

  # Coverage Performance

  <table class="table">
    <tr><th></th><th>Lines</th><th>Branches</th><th>Oneshot</th></tr>
    <!-- run 01-Internals/benchmark_overhead.rb with different lines commented in -->
    <tr><th>Ruby</th><td>50%</td><td>100%</td><td>2%</td></tr>
    <!-- see 01-Internals/benchmark_overhead.rb with different lines commented in -->
    <tr><td colspan="4"><pre>50_000_000.times { example }</pre></td></tr>
    <tr><th>Rails</th><td>0.5%</td><td>2.4%</td><td>0%</td></tr>
    <tr><td colspan="4"><pre>app.get "/"</pre></td></tr>
  </table>

  ???

  - to improve performance use `set_trace_func` directly via sampling approach (coverband)

  ---

  # Coverage Performance

  <img src="assets/performance.png" width="100%"/>

  by @mametter

  ???

  From 2017 RubyKaigii talk https://www.slideshare.net/mametter/an-introduction-and-future-of-ruby-coverage-library

  ---

  # Recap

  - `Coverage.start` = simple lines
  - `Coverage.start branches: true` = weird but useful
  - `Coverage.start oneshot_lines: true` = fast but hard to use
  - `Coverage.result / Coverage.peek_result`

  ---

  # Plan

  - <del>Code Coverage Overview</del>
  - Actionable Coverage
  - Hack Forked Coverage
  - Coverage Wishlist

  ---

  # Actionable Coverage

  - Mindset
  - Problems
  - Solution
  - Migration

  ---

  # Mindset

  - Not a metric, easy to cheat on

  ???

  - cheat: use `||` instead of if, only unit test

  ---

  # Mindset

  - Not a metric, easy to cheat on
  - 100% coverage != good test

  ???

  - 100% = no stupid errors

  ---

  # Mindset

  - Not a metric, easy to cheat on
  - 100% coverage != good test
  - A helper/fallback: <br/>
  "Did you write a test for that ?"<br/>
  "Why does it rescue ?"<br/>
  "What happens when xyz ?"

  ???

  - often thought I had coverage but never covered edge case / edge cas was unreachable

  ---

  # Problems

  - Slow feedback

  ???

  - have to make PR and wait for hook, run all tests, open browser
  - adds frustration / not actionable

  ---

  # Problems

  - Slow feedback
  - Impossible to reach 100% coverage

  ???

  - setup code and edge-cases
  - broken window effect

  ---

    # Problems

  - Slow feedback
  - Impossible to reach 100% coverage
  - Bikeshedding about what % is ok

  ???

  - 100% cannot be reached so we guess
  - rewrite a statement to be readable and suddenly it's not covered

  ---

    # Problems

  - Slow feedback
  - Impossible to reach 100% coverage
  - Bikeshedding about what % is ok
  - Complicated setup

  ???

  - install webhooks
  - pay providers
  - get accounts for contributors
  - error? -> irreproducible locally

  ---

  # Solution

  ???

  - the solution we need is ...

  ---

  # Solution

  - quick, atomic development feedback

  ???

  - run a single file, matches a single test, small runtime overhead, exact location, console output
  - easy to contribute when tests are easy to find
  - encourage seeking quick local feedback instead of taking a break after PRs
  - bad PRs still fail but can be reproduced

  ---

  # Solution

  - quick, atomic development feedback
  - mark intentional gaps to get 100%

  ???

  - call out gaps explicitly, raise awareness when editing code, 100% avoid broken windows

  ---

  # Solution

  - quick, atomic development feedback
  - mark intentional gaps to get 100%
  - simple/local/free setup

  ???

  who wants a complicated, remote, paid setup ?

  ---

  # Solution

  - quick, atomic development feedback
  - mark intentional gaps to get 100%
  - simple/local/free setup
  - branch coverage

  ---

  # SingleCov

  Missing coverage on every ðŸ’š run

  ```Bash
  rspec spec/foobar_spec.rb
  ......
  114 example, 0 failures

  lib/foobar.rb new uncovered lines introduced (2 current vs 0 configured)",
  Uncovered lines:
  lib/foobar.rb:22
  lib/foobar.rb:23
  ```

  ???

  - minitest + rspec
  - catch coverage issues before making PRs
  - makes PRs fail when coverage is missing
  - calls out exact location
  - configure allowed gaps

  ---

  # SingleCov

  Automatic bootstrap script to add coverage enforcement for legacy apps

  ```Ruby
  SingleCov.covered! uncovered: 42

  SingleCov.assert_used   # all tests have coverage

  SingleCov.assert_tested # all files have tests
  ```

  ???

  - stops newly uncovered code and allows slowly working through backlog
  - helpers to test all files have tests

  ---

  # SingleCov

  - 2-5% runtime overhead on single files, compared to 10-20% for SimpleCov
  - Branch coverage on ruby 2.5+ (disable via branches: false)
  - Use with forking_test_runner for per test coverage

  ---

  # Migration

  Automated onboarding + divide & conquer

  Inline comments

  ```Ruby
  SingleCov.covered! uncovered: 1
  ==
  SingleCov.covered!

  if this_can_never_happen
    raise # uncovered
  end
  ```

  ---

  # Recap

  - Want local/fast feedback with marked uncovered
  - Use `single_cov` + `forking_test_runner`
  - Stop the bleeding, then divide and conquer

  ---

  # Plan

  - <del>Code Coverage Overview</del>
  - <del>Actionable Coverage</del>
  - Hack Forked Coverage
  - Coverage Wishlist

  ---

  # Hack forked coverage

  - Avoid having to run all tests
  - Unit tests should cover file under test
  - Fork to capture per-file coverage

  ???

  - Can still have integration tests, but unit have to cover all code
  - but forking does not play nice with coverage ... *flip*

  ---

  # Hack forked coverage

  Forking resets coverage

  <!-- see 03-forked/forked_reset.rb -->
  ```Ruby
  require 'coverage'
  Coverage.start
  require_relative 'example'
  example
  fork { puts Coverage.result }
  {"example.rb"=>[0, 0, 0, nil, 0, nil, nil]}
  ```

  ???

  Makes full coverage unreachable since requires cannot be redone

  ---

  # Hack forked coverage


  <!-- see 03-forked/combine_in_fork.rb -->
  ```Ruby
  # ... load everything
  peek = Coverage.peek_result
  fork do
    # ... test
    result = Coverage.result.map do |file, cov|
      cov.each_with_index.map do |c, i|
        peek[file][i] ? peek[file][i] + c : c
      end
    end
  end
  {"example.rb"=>[1, 2, 1, nil, 1, nil, nil]}
  ```

  ---

  # Hack forked coverage

  ```Bash
  forking-test-runner test/ --merge-coverage
  ```

  ???

  - under the hood of forking-test-runner
  - integrates well with single_cov and makes CI coverage same as local (often more because it runs all tests)

  ---

  # Hack forked coverage

  ```Bash
  forking-test-runner test/ --merge-coverage
  ```

  - handles edge-cases
  - preloads AR fixtures / helpers etc
  - handles branch coverage

  ???

  - maybe in the future oneshot

  ---

  # Combine in parent

  fork & combine coverage

  <!-- see 03-forked/combine_in_parent.rb -->
  ```Ruby
  # ... load everything
  read, write = IO.pipe
  Process.wait(fork do
    # ... test
    Marshal.dump(Coverage.result, write)
  end)
  result = Coverage.result + Marshal.load(read)
  {"example.rb"=>[1, 2, 1, nil, 1, nil, nil]}
  ```

  ???

  test destructive behavior in fork and combine after

  ---

  # Recap

  - fork and coverage don't play nice
  - use peek_result to get results in-between
  - use IO.pipe to send coverage

  ---

  # Plan

  - <del>Code Coverage Overview</del>
  - <del>Actionable Coverage</del>
  - <del>Hack forked coverage</del>
  - Coverage Wishlist

  ???

  backend tools we need to improve coverage tooling

  ---

  # Coverage Wishlist

  - Oneshot usable for coverage calculations
  - Oneshot branches

  <!-- see 04-wishlist/onheshot.rb -->
  ```Ruby
  require 'coverage'
  Coverage.start oneshot_lines: :boolean
  require_relative 'example'
  example 1
  Coverage.result
  {"example.rb"=>{:oneshot_lines=>[true, false, nil, true]}}
  ```

  ???

  Could simply grep false and report on that

  ---

  # Coverage Wishlist

  Inherit coverage in forks

  <!-- see 04-wishlist/adding.rb -->
  ```Ruby
  require 'coverage'
  Coverage.start inherit_on_fork: true
  require_relative 'example'
  example 1
  fork do
    example 2
    Coverage.result
  end
  ```

  ???

  branch coverage needs lots of merge logic

  ---

  # Coverage Wishlist

  Coverage for default parameters

  ```Ruby
  def foo(a = default)
    puts a
  end
  ```

  a was passed in <-> a was not passed in

  ---

  # Coverage Wishlist

  Coverage for logical operators

  ```Ruby
  # covered
  success || raise("Ooops")

  # not covered
  raise("Ooops") unless success
  ```

  ---

  # Coverage Wishlist

  Path coverage

  ```Ruby
  a = a ? : 1 : 2
  a = a ? : 3 : 4
  ```

  4 Paths through this code
  1/3 + 1/4 + 2/3 + 2/4

  ???

  super annoying to get 100% coverage but could be interesting for security/complicated things

  ---

  # Coverage Wishlist

  Turn on for loaded code -> per request/controller coverage

  ```Ruby
  Coverage.start add_to_existing: true
  ```

  ---

  # Recap

  - make oneshot automatable
  - oneshot branches
  - inherit coverage on fork
  - default params coverage
  - logical operators coverage
  - path coverage
  - work for preloaded code

  ---

  class: center, middle

  # Thank you!

  <table>
  <tr><td>github.com/grosser/</td><td style="text-align: left">ruby-coverage-talk</td></tr>
  <tr><td></td><td style="text-align: left">single_cov</td></tr>
  <tr><td></td><td style="text-align: left">forking_test_runner</td></tr>
  <tr><td></td><td style="text-align: left">maxitest</td></tr>
  <tr><td></td><td style="text-align: left">testrbl</td></tr>
  </table>

  ???

  Slides / examples / PRs welcome

</textarea>
<script src="assets/remark-latest.min.js">
</script>
<script>
  remark.create(
    {
      ratio: '4:3',
      highlightLanguage: 'ruby'
    }
  );
</script>
</body>
</html>
